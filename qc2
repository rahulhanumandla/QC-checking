import fitz
import re
import textwrap

proxy_path = "proxy.pdf"
notice_path = "notice.pdf"
output_pdf = "Agenda_Comparison_Report.pdf"


# -------------------------
# Extract full text from a PDF
# -------------------------
def extract_full_text(path):
    doc = fitz.open(path)
    full_txt = ""
    for p in doc:
        full_txt += p.get_text()
    return full_txt


# -------------------------
# Stop reading after last proposal label
# -------------------------
def trim_after_last_label(text):
    # A proposal label: 1., 1a., 01), 12)
    label_re = re.compile(r'^\s*(\d{1,2}[a-z]?\.|0\d\)|\d{1,2}\))', re.MULTILINE)
    matches = list(label_re.finditer(text))

    if not matches:
        return text  # no proposals found

    last_match = matches[-1]
    end_pos = last_match.start()

    # Cut text from last proposal to end
    trimmed = text[end_pos:]

    # Stop at first large blank block (signature area usually)
    trimmed = trimmed.split("\n\n")[0]

    return trimmed


# -------------------------
# Convert agenda text → dictionary(label → text)
# -------------------------
def extract_proposals(text):
    label_re = re.compile(r'^\s*(\d{1,2}[a-z]?\.|0\d\)|\d{1,2}\))')
    proposals = {}
    current_label = None

    for line in text.splitlines():
        m = label_re.match(line)
        if m:
            label = m.group(1).strip()
            remainder = line[m.end():].strip()
            proposals[label] = remainder
            current_label = label
        else:
            if current_label:
                proposals[current_label] += " " + line.strip()

    # Normalize spaces
    for k in proposals:
        proposals[k] = re.sub(r'\s+', ' ', proposals[k]).strip()

    return proposals


# -------------------------
# Compare proposals
# -------------------------
def compare(notice_dict, proxy_dict):
    labels = sorted(set(notice_dict.keys()) | set(proxy_dict.keys()))
    results = []

    for lbl in labels:
        n = notice_dict.get(lbl)
        p = proxy_dict.get(lbl)

        if n is None:
            results.append((lbl, "MISSING_IN_NOTICE"))
        elif p is None:
            results.append((lbl, "MISSING_IN_PROXY"))
        elif n == p:
            results.append((lbl, "MATCH"))
        else:
            wrapped_n = "\n".join(textwrap.wrap(n, width=70))
            wrapped_p = "\n".join(textwrap.wrap(p, width=70))
            results.append((
                lbl,
                f"MISMATCH\nNOTICE: {wrapped_n}\nPROXY:  {wrapped_p}"
            ))

    return results


# -------------------------
# PDF Report Generator
# -------------------------
def create_report(results, output_path):
    doc = fitz.open()
    page = doc.new_page()
    y = 40

    page.insert_text((40, 20), "AGENDA COMPARISON REPORT", fontsize=16)

    for lbl, status in results:
        for line in status.split("\n"):
            if y > 760:
                page = doc.new_page()
                y = 40

            page.insert_text((40, y), f"{lbl}: {line}", fontsize=11)
            y += 18
        y += 10  # spacing between items

    doc.save(output_path)
    doc.close()


# -----------------------------------------------------
# PIPELINE
# -----------------------------------------------------

# Extract text
notice_raw = extract_full_text(notice_path)
proxy_raw = extract_full_text(proxy_path)

# Trim signature and extra language
notice_text = trim_after_last_label(notice_raw)
proxy_text = trim_after_last_label(proxy_raw)

# Convert to dictionaries
notice_dict = extract_proposals(notice_text)
proxy_dict = extract_proposals(proxy_text)

# Compare
results = compare(notice_dict, proxy_dict)

# Report
create_report(results, output_pdf)

print("DONE! Report saved as:", output_pdf)
