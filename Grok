import fitz
import openai
import re
import textwrap
import json

# ------------------- CONFIG -------------------
proxy_path = "proxy.pdf"
notice_path = "notice.pdf"
output_pdf = "Agenda_Comparison_Report.pdf"

# Set your OpenAI API key
openai.api_key = "YOUR_API_KEY"

# ------------------- 1. Extract left agenda area -------------------
def extract_agenda_text(path):
    doc = fitz.open(path)
    cutoff_x = 7.5 * 72  # first 7.5 inches

    label_re = re.compile(r'^\s*(\d{1,2}[a-z]?\.|0\d\)|\d{1,2}\))', re.MULTILINE)

    for pno in range(len(doc)):
        page = doc[pno]
        clip = fitz.Rect(0, 0, cutoff_x, page.rect.height)
        txt = page.get_text("text", clip=clip)

        if label_re.search(txt):
            return txt

    # fallback: first page left area
    page = doc[0]
    clip = fitz.Rect(0, 0, cutoff_x, page.rect.height)
    return page.get_text("text", clip=clip)

# ------------------- 2. Use GPT to extract proposals -------------------
def extract_proposals_with_gpt(text):
    prompt = f"""
You are an assistant for reading proxy agendas.
Extract ONLY the numbered proposals from the text below.
Ignore everything else like recommendations, company info, signatures, and voting instructions.
Return the results as a JSON object where keys are labels and values are the proposal text.

Text:
\"\"\"{text}\"\"\"
"""

    try:
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            temperature=0
        )
        json_text = response['choices'][0]['message']['content']

        # Sometimes GPT adds extra text before/after JSON, extract JSON part
        json_start = json_text.find("{")
        json_end = json_text.rfind("}") + 1
        proposals = json.loads(json_text[json_start:json_end])

        # Ensure all values are strings
        proposals = {k: str(v).strip() for k, v in proposals.items()}
        return proposals
    except Exception as e:
        print("GPT extraction error:", e)
        return {}

# ------------------- 3. Compare Notice → Proxy -------------------
def compare(notice_dict, proxy_dict):
    results = []

    for lbl, n_text in notice_dict.items():
        p_text = proxy_dict.get(lbl)

        if p_text is None:
            results.append((lbl, "MISSING_IN_PROXY"))
            continue

        if n_text == p_text:
            results.append((lbl, "MATCH"))
        else:
            results.append((lbl, f"MISMATCH → Notice: '{n_text}' | Proxy: '{p_text}'"))

    return results

# ------------------- 4. Create PDF report -------------------
def create_report(results, output_filepath):
    doc = fitz.open()
    page = doc.new_page()

    # Title
    page.insert_text((40, 20), "AGENDA COMPARISON REPORT", fontsize=16)

    # Margins and settings
    left_margin = 40
    right_margin = 550
    top_margin = 60
    bottom_margin = 780
    font_size = 11
    line_height = font_size + 3
    max_chars_per_line = 90

    y = top_margin

    for label, status in results:
        text = f"{label}: {status}"
        wrapped_lines = textwrap.wrap(text, width=max_chars_per_line)

        for line in wrapped_lines:
            if y + line_height > bottom_margin:
                page = doc.new_page()
                y = 40

            page.insert_text((left_margin, y), line, fontsize=font_size)
            y += line_height

        y += 5  # small space after each proposal

    doc.save(output_filepath)
    doc.close()

# ------------------- PIPELINE -------------------
print("Extracting notice agenda...")
notice_text = extract_agenda_text(notice_path)
print("Extracting proxy agenda...")
proxy_text  = extract_agenda_text(proxy_path)

print("Extracting proposals using GPT...")
notice_dict = extract_proposals_with_gpt(notice_text)
proxy_dict  = extract_proposals_with_gpt(proxy_text)

print("Comparing proposals...")
results = compare(notice_dict, proxy_dict)

print("Generating report PDF...")
create_report(results, output_pdf)

print("DONE! Saved as", output_pdf)