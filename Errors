import fitz
import re
import textwrap
import re
from openai import OpenAI

# ---------------- CONFIG ----------------
proxy_path = "proxy.pdf"
notice_path = "notice.pdf"
output_pdf = "Agenda_Comparison_Report.pdf"
openai_api_key = "YOUR_OPENAI_API_KEY"  # Replace with your key

client = OpenAI(api_key=openai_api_key)

# ---------------- 1. Extract left agenda area ----------------
def extract_agenda_text(path):
    doc = fitz.open(path)
    cutoff_x = 7.5 * 72  # 7.5 inches in points
    label_re = re.compile(r'^\s*(\d{1,2}[a-z]?\.|0\d\)|\d{1,2}\))', re.MULTILINE)

    for pno in range(len(doc)):
        page = doc[pno]
        clip = fitz.Rect(0, 0, cutoff_x, page.rect.height)
        txt = page.get_text("text", clip=clip)
        if label_re.search(txt):
            return txt

    # fallback
    page = doc[0]
    clip = fitz.Rect(0, 0, cutoff_x, page.rect.height)
    return page.get_text("text", clip=clip)

# ---------------- 2. AI batch filtering ----------------
def ai_filter_proposal(proposal_block):
    """
    Send the full proposal block to AI and get only the lines
    that are part of the proposal description.
    """
    prompt = f"""
    You are given text extracted from a corporate proxy/notice PDF.
    Some lines may be extra information like nominees, voting instructions, or signatures.
    Extract ONLY the lines that are part of the actual proposal description.
    Return them as plain text, preserving the line order.

    Text:
    {proposal_block}
    """
    try:
        response = client.chat.completions.create(
            model="gpt-5-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        filtered_text = response.choices[0].message.content.strip()
        return filtered_text
    except Exception as e:
        print("AI error:", e)
        # fallback: return entire block if AI fails
        return proposal_block

# ---------------- 3. Extract proposals using AI ----------------
def extract_proposals(text):
    proposals = {}
    current_label = None
    lines_buffer = []

    pattern = re.compile(r'^\s*(\d{1,2}[a-z]?\.|0\d\)|\d{1,2}\))')

    for line in text.splitlines():
        line = line.strip()
        if not line:
            continue

        m = pattern.match(line)
        if m:
            # Save previous proposal
            if current_label and lines_buffer:
                proposals[current_label] = ai_filter_proposal("\n".join(lines_buffer))
            current_label = m.group(1)
            content = line[m.end():].strip()
            lines_buffer = [content] if content else []
        else:
            if current_label:
                lines_buffer.append(line)

    # Save last proposal
    if current_label and lines_buffer:
        proposals[current_label] = ai_filter_proposal("\n".join(lines_buffer))

    # Collapse extra spaces
    for k in proposals:
        proposals[k] = re.sub(r'\s+', ' ', proposals[k]).strip()

    return proposals

# ---------------- 4. Compare Notice → Proxy ----------------
def normalize(text):
    return re.sub(r'\s+', ' ', text).strip()

def compare(notice_dict, proxy_dict):
    results = []
    for lbl, n_text in notice_dict.items():
        p_text = proxy_dict.get(lbl)
        if p_text is None:
            results.append((lbl, "MISSING_IN_PROXY"))
            continue
        if normalize(n_text) == normalize(p_text):
            results.append((lbl, "MATCH"))
        else:
            results.append((lbl, f"MISMATCH → Notice: '{n_text}' | Proxy: '{p_text}'"))
    return results

# ---------------- 5. Generate PDF report ----------------
def create_report(results, output_filepath):
    doc = fitz.open()
    page = doc.new_page()

    # Title
    page.insert_text((40, 20), "AGENDA COMPARISON REPORT", fontsize=16)

    left_margin = 40
    right_margin = 550
    top_margin = 60
    bottom_margin = 780
    font_size = 11
    line_height = font_size + 3
    max_chars_per_line = 90

    y = top_margin

    for label, status in results:
        text = f"{label}: {status}"
        wrapped_lines = textwrap.wrap(text, width=max_chars_per_line)

        for line in wrapped_lines:
            if y + line_height > bottom_margin:
                page = doc.new_page()
                y = 40
            page.insert_text((left_margin, y), line, fontsize=font_size)
            y += line_height
        y += 5

    doc.save(output_filepath)
    doc.close()

# ---------------- 6. Pipeline ----------------
notice_text = extract_agenda_text(notice_path)
proxy_text  = extract_agenda_text(proxy_path)

notice_dict = extract_proposals(notice_text)
proxy_dict  = extract_proposals(proxy_text)

results = compare(notice_dict, proxy_dict)
create_report(results, output_pdf)

print("DONE! Saved as", output_pdf)